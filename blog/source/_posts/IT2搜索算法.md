---
title: IT2搜索算法
date: 2024-07.02 1:29:40
tags:
- Algorithmus
categories:
- Informationstechnik
- Algorithmus
mathjax: true
---



## 总结

| 算法 | 时间复杂度（最坏情况） | 空间复杂度 |
|------|----------------------|------------|
| 线性搜索 | \( O(n) \) | \( O(1) \) |
| 二分查找 | \( O(\log n) \) | \( O(1) \)（迭代），\( O(\log n) \)（递归） |
| 广度优先搜索 (BFS) | \( O(V + E) \) | \( O(V) \) |
| 深度优先搜索 (DFS) | \( O(V + E) \) | \( O(V) \) |
| 环检测（DFS） | \( O(V + E) \) | \( O(V) \) |
| 环检测（并查集） | \( O(E \log V) \) | \( O(V) \) |
| 最短路径（Dijkstra） | \( O(V^2) \) 或 \( O((V + E) \log V) \) | \( O(V) \) |
| 最短路径（Bellman-Ford） | \( O(VE) \) | \( O(V) \) |
| 关键路径 | \( O(V + E) \) | \( O(V) \) |

## 线性搜索（Linear Search）

线性搜索逐个检查数组中的每个元素，直到找到目标元素或搜索完整个数组。
时间复杂度为 O(n)，其中 n 是数组的长度。
不需要数组有序。

### 线性搜索的伪代码

```python
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # 返回目标元素的索引
    return -1  # 如果找不到目标元素，返回 -1
```

### 线性搜索的流程图

以下是线性搜索的流程图，它描述了搜索过程中每一步的操作：

```plaintext
开始
  ↓
初始化索引 i = 0
  ↓
i < 数组长度? ──否──→ 返回 -1
  ↓是
arr[i] == 目标值? ──是──→ 返回 i
  ↓否
i = i + 1
  ↓
回到检查 i < 数组长度?
```

### 详细步骤解释

1. **开始**：启动线性搜索过程。
2. **初始化索引 i = 0**：将索引 `i` 初始化为 `0`，表示从数组的第一个元素开始。
3. **检查条件 i < 数组长度**：
   - 如果 `i` 等于或大于数组的长度，表示已经检查了所有元素，目标元素不存在于数组中，返回 `-1`，搜索结束。
   - 如果 `i` 小于数组的长度，继续下一步。
4. **检查 arr[i] 是否等于目标值**：
   - 如果 `arr[i] == 目标值`，找到了目标元素，返回当前索引 `i`，搜索结束。
   - 如果 `arr[i] != 目标值`，继续下一步。
5. **索引加一**：将索引 `i` 增加 `1`，移动到数组的下一个元素。
6. **重复步骤 3 和 4**：继续检查下一个元素，直到找到目标元素或检查完整个数组。


## 二分法搜索

二分搜索在有序数组中进行。它通过反复将搜索区间一分为二来缩小搜索范围。
时间复杂度为 O(log n)，其中 n 是数组的长度。
数组必须是有序的才能使用二分搜索。


为了找到 `9, 8, 2, 4, 3, 6, 5` 这个数组中的元素 `3`，首先需要对数组进行排序，因为二分搜索只能在有序数组上进行。排序后的数组是 `2, 3, 4, 5, 6, 8, 9`。


### 步骤 1：初始化边界

- 数组：`[2, 3, 4, 5, 6, 8, 9]`
- 目标元素：`3`
- 左边界 (`left`)：`0`
- 右边界 (`right`)：`6`

### 步骤 2：计算中间索引

- 计算中间索引 (`mid`)：
  ```
  mid = left + (right - left) // 2
  mid = 0 + (6 - 0) // 2
  mid = 3
  ```

- 检查中间元素：
  ```
  arr[mid] = arr[3] = 5
  ```

- 目标元素 `3` 小于 `5`，所以更新右边界：
  ```
  right = mid - 1 = 3 - 1 = 2
  ```

### 步骤 3：再次计算中间索引

- 计算新的中间索引：
  ```
  mid = left + (right - left) // 2
  mid = 0 + (2 - 0) // 2
  mid = 1
  ```

- 检查中间元素：
  ```
  arr[mid] = arr[1] = 3
  ```

- 找到目标元素 `3`，搜索成功。

### 二分搜索的伪代码

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid  # 返回目标元素的索引
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1  # 如果找不到目标元素，返回 -1
```

### 完整步骤总结

1. 排序后的数组：`[2, 3, 4, 5, 6, 8, 9]`
2. 初始化：
   - `left = 0`
   - `right = 6`
3. 第一次计算：
   - `mid = 3`
   - `arr[3] = 5`
   - 更新 `right = 2`
4. 第二次计算：
   - `mid = 1`
   - `arr[1] = 3`
   - 找到目标元素，返回索引 `1`

通过二分搜索，元素 `3` 在排序后的数组中的索引为 `1`。


## 广度优先搜索


### 广度优先搜索（BFS）的概念

广度优先搜索是一种遍历或搜索图或树数据结构的算法。它从根节点开始，首先访问节点本身，然后访问其所有邻居节点，再访问这些邻居的邻居，依此类推。广度优先搜索使用队列数据结构来实现。

### 广度优先搜索的步骤

1. 从起始节点开始，访问该节点并将其标记为已访问。
2. 将该节点的所有未访问邻居节点依次入队。
3. 从队列中取出一个节点，重复步骤 1 和 2，直到队列为空。

### 广度优先搜索的伪代码

```python
def breadth_first_search(graph, start):
    visited = []         # 已访问节点列表
    queue = [start]      # 初始化队列，包含起始节点

    while queue:
        node = queue.pop(0)  # 从队列头部取出一个节点
        if node not in visited:
            visited.append(node)  # 访问该节点并标记为已访问
            neighbors = graph[node]  # 获取该节点的所有邻居节点

            for neighbor in neighbors:
                if neighbor not in visited:
                    queue.append(neighbor)  # 将所有未访问的邻居节点入队

    return visited
```

### 广度优先搜索的图示例

假设我们有以下图结构：

```
    A
   / \
  B   C
 /|   |\
D E   F G
```

从节点 `A` 开始进行广度优先搜索。

### 执行 BFS 的步骤

![Test](/images/Breitensuche.png)
1. **初始化**：
   - 起始节点：`A`
   - 已访问节点列表：`[]`
   - 队列：`[A]`

2. **第一步**：
   - 访问节点 `A`，将 `A` 标记为已访问。
   - 已访问节点列表：`[A]`
   - 队列：`[B, C]`（`A` 的邻居）

3. **第二步**：
   - 访问节点 `B`，将 `B` 标记为已访问。
   - 已访问节点列表：`[A, B]`
   - 队列：`[C, D, E]`（`B` 的邻居）

4. **第三步**：
   - 访问节点 `C`，将 `C` 标记为已访问。
   - 已访问节点列表：`[A, B, C]`
   - 队列：`[D, E, F, G]`（`C` 的邻居）

5. **继续执行**：
   - 访问节点 `D`，将 `D` 标记为已访问。
   - 已访问节点列表：`[A, B, C, D]`
   - 队列：`[E, F, G]`

   - 访问节点 `E`，将 `E` 标记为已访问。
   - 已访问节点列表：`[A, B, C, D, E]`
   - 队列：`[F, G]`

   - 访问节点 `F`，将 `F` 标记为已访问。
   - 已访问节点列表：`[A, B, C, D, E, F]`
   - 队列：`[G]`

   - 访问节点 `G`，将 `G` 标记为已访问。
   - 已访问节点列表：`[A, B, C, D, E, F, G]`
   - 队列：`[]`

队列为空，搜索完成。

## 深度优先搜索（DFS）

深度优先搜索（DFS）是一种用于遍历或搜索树结构或图的算法，它沿着一条路径深入探索直到尽头，然后通过回溯（返回上一节点）探索下一条路径。这种策略通过尽可能深地探索图的分支，来访问图中的所有顶点。
![Test](/images/Tiefensuche.png)
#### 实现方法
DFS 可以用递归或者栈来实现，这两种方法在逻辑上是等价的：

1. **递归实现**：
   - 从一个顶点开始，标记它为已访问。
   - 查找当前顶点的所有未访问的邻接顶点，递归地执行 DFS。
   - 当所有邻接点都被访问后，递归将自然结束，回到上一个顶点，继续探索其他邻接点。

2. **栈实现**：
   - 将起始顶点放入栈中，并标记为已访问。
   - 循环直到栈为空：
     - 弹出栈顶元素。
     - 获取该顶点的所有未访问邻接顶点，将它们压入栈中，并标记为已访问。

#### 应用
DFS 在许多应用中都很有用，包括：
- 解决迷宫问题。
- 组件连通性。
- 拓扑排序。
- 找出所有可能的路径。

### 环检测

环检测是在图中查找是否存在至少一个环的过程，这对于理解图的结构特别重要，尤其是在处理有向图时。

#### 有向图环检测
使用 DFS 来检测有向图中的环：
- 使用三种颜色来标记每个顶点的状态：白色（未访问），灰色（访问中），黑色（已访问完成）。
- 从任意未访问的顶点开始执行 DFS。
- 如果在 DFS 过程中，访问到一个灰色的顶点，则表示找到了一个环。
- 访问结束后，将顶点标记为黑色。

#### 无向图环检测
在无向图中使用 DFS 检测环：
- 对每个未访问的顶点执行 DFS。
- 在 DFS 过程中，如果一个顶点的邻接顶点已被访问，并且不是当前顶点的直接前驱，则表示存在环。


## 最短路径与关键路径

### 最短路径

在加权图中，最短路径问题涉及找到两个顶点间路径权重之和最小的路径。这种问题在现实世界中非常常见，如网络路由、导航系统等。

**Dijkstra算法** 是解决最短路径问题最著名的算法之一，特别是在所有边的权重都为非负数时效果最好。Dijkstra算法使用了贪心策略，每一步都选择未处理的顶点中，当前距离起点距离最短的顶点来处理，确保了每次处理的都是当前看来最优的选择。

**Bellman-Ford算法** 则可以处理图中包含负权重的边，虽然效率比Dijkstra算法低，但它能处理更复杂的图结构，同时能检测图中是否存在负权环。

#### 关键路径

关键路径分析是项目管理中的一个重要工具，用于确定项目的最短完成时间。它通过识别项目中时间最长的活动序列（即关键路径）来实现，这个路径上的任何延迟都会直接导致整个项目的延迟。

关键路径方法（CPM）通常是在一个有向无环图（DAG）中实施的，其中每个节点表示项目中的一个任务，每个有向边表示两个任务之间的先后关系。关键路径是从起点到终点的最长路径，与Dijkstra算法求最短路径相反。


### Dijkstra算法概述

在图中找到一个节点到其他所有节点的最短路径的算法。特别适合用于包含非负权重边的加权图。
![Test](/images/GreeyeundDijkstra.png)

#### 工作原理

Dijkstra算法使用了一种贪心的方法，即每次扩展最近的未处理节点，更新其邻接节点的距离。这个算法可以用一个优先队列来优化，以快速从一组未处理的节点中找出当前距离最短的节点。

#### 算法步骤

1. **初始化**：
   - 选择图中的起始节点作为源节点。
   - 将所有节点的最短路径估计值设为无穷大，源节点设为0（因为源节点到自己的最短距离是0）。
   - 使用一个优先队列来存储所有节点及其当前的最短路径估计值。优先队列按照节点的最短路径估计值排序。

2. **节点处理**：
   - 从优先队列中移除拥有最小距离估计的节点，称为当前节点。
   - 对于当前节点的每个邻接节点，计算通过当前节点到达它的距离。如果这个距离小于已知的最短路径估计，则更新该邻接节点的最短路径估计和前驱节点。
   - 更新了估计值的邻接节点在优先队列中的位置。

3. **重复**：
   - 重复步骤2，直到优先队列为空或者找到目标节点的最短路径（如果只需要找到一个特定的目标节点的最短路径）。

4. **路径重构**：
   - 从目标节点开始，逆向追踪前驱节点，直到源节点，这样可以重构出最短路径。

#### 特点

- **效率**：如果不使用优先队列，算法的时间复杂度为 \(O(V^2)\)，其中 \(V\) 是顶点数。使用优先队列（通常实现为二叉堆），时间复杂度可以降低到 \(O((V+E) \log V)\)，其中 \(E\) 是边数。
- **应用**：广泛用于实际问题如路由算法（如互联网路由协议 OSPF 和 IS-IS 的算法基础），地图绘制，网络流问题等。
- **局限性**：Dijkstra算法不能处理含有负权边的图。在这种情况下，通常使用Bellman-Ford算法。

Dijkstra算法因其实现简单和效率高而被广泛使用，是解决最短路径问题的经典方法之一。